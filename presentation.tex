%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[t, 12pt]{beamer}            % Generate slides
%\documentclass[handout]{beamer}   % Generate handouts (6 slides to 1 page)
%\documentclass[aspectratio=169]{beamer}  % Use widescreen 16:9 aspect ratio
    % Possible aspect ratios are 16:9, 16:10, 14:9, 5:4, 4:3 (default) and 3:2
    % (Remember to remove the colon)

%\usetheme{UoB}
%\usetheme[compress]{UoB}     % Compress the margins
\usetheme[nourl]{UoB}        % Remove the footer with the URL
%\usetheme[nowatermark]{UoB}  % Remove the watermark from the title page

% Generate handouts with notes (3 slides + 3 notes to 1 page)
%\mode<handout>{
%  \pgfpagesuselayout{3 on 1 with notes}[a4paper,border shrink=10mm]
%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title[Secure Two Party Computation]{Secure Two Party Computation}
\subtitle{A practical comparison of recent protocols}
\author{Nick Tutte}
\institute{University of Bristol}
\date{15th May 2015}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\titlepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Project Overview}
	\begin{itemize}[<+->]
		\item Secure Multiparty Computation is a long standing problem in cryptography.
		\begin{itemize}
			\item How can mutually distrusting parties collaborate compute a function without revealing their inputs?
		\end{itemize}
		\item A subset of this problem is Secure Two Party Computation (S2C).
		\item Yao Garbled Circuits are one approach to S2C, but naive Yao Circuits only provide security against passive adversaries. 
		\item Recently many protocols have been proposed to use Yao Circuits to provide security in the presence of active adversaries. 
		\item Our aim was to implement some of these recent protocols so we could compare their performance.
	\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Secure Multiparty Computation}
	\begin{itemize}[<+->]
		\item Given $n$ parties who each have an input $x_i$
		\item Parties wish to compute a function $(y_1, ..., y_n) = f(x_1, ..., x_n)$
		\item But they want the following security properties,
		\begin{itemize}
			\item Privacy - Participating parties only learn their output.
			\item Correctness - Output is correct evaluation of the function \emph{given the inputs}.
			\item Independence of inputs - Participating parties only learn their output.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Yao's Protocol}
	\begin{itemize}[<+->]
		\item Proposed by Andrew Yao in 1986. Whilst it's primarily for Two Party computation it can be extended to Multiparty computation.
		\item  The basic idea,
		\begin{itemize}
			\item One party is labelled the `Builder' and the other is the `Executor'.
			\item The Builder constructs a binary circuit representing the function.
			\item The Builder then `garbles' this circuit, encrypting it in such a way that it can be evaluated without revealing information about the inputs, and sends it to the Executor.
			\item The Builder's inputs are hardcoded, the Executor's inputs are obtained by Oblivious Transfers.
			\item Using these inputs the Executor can then evaluate the circuit and so the function.
		\end{itemize}
	\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\begin{block}{Oblivious Transfer}
		\vspace{0.2cm}
		\begin{figure}[!htb]
			\centering
			\begin{minipage}{0.45\textwidth}
				\centering
			\textbf{Receiver}\\
				Inputs : $b \in \{0, 1\}$\\
				Outputs : $x_b$\\
			\end{minipage}
			\begin{minipage}{0.45\textwidth}
				\centering
				\textbf{Sender}\\
				Inputs : $x_0, x_1 \in \{0, 1\}^l$\\
				Outputs : $\emptyset$\\
			\end{minipage}
		\end{figure}

		Formal definition of the functionality of a one-out-of-two OT protocol. The Receiver should learn nothing about the value of $x_{1-b}$ and the Sender should learn nothing about $b$.
	\end{block}

	We will not dwell on the details of Oblivious Transfer, suffice to say it is possible, if anyone is interested in seeing a concrete protocol I suggest the Naor-Pinkas Oblivious Transfer.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{The Security of Yao's Protocol}
	\begin{itemize}[<+->]
		\item As already mentioned Yao Circuits are only secure in the presence of passive adversaries. \footnotemark
		\item In naive Yao Circuits the Executor has no way to know if the circuit given to it by the Builder actually computes the function it purports to.
		\item There are two main approaches to overcoming this,
		\begin{itemize}
			\item Cut and Choose.
			\item Commit and Prove.
		\end{itemize}
	\end{itemize}
	
	\footnotetext[1]{For a formal proof of this see ``A Proof of Security of Yao's Protocol for Two-Party Computation'' by Lindell and Pinkas (2006) }
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Cut and Choose - Concept}
	\begin{itemize}[<+->]
		\item All three protocols we implemented are based on Cut and Choose.
		\item The Builder now generates many garbled circuits and sends them to the Executor.
		\item The Executor then picks a set of these circuits and asks the Builder to open them so they can be checked for correctness.
		\item If all check circuits pass then the rest of the circuits are evaluated.
		\item So a malicious Builder must now guess which circuits will be checked.
	\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Cut and Choose - Issues}
	\begin{itemize}[<+->]
		\item Cut and Choose seems trivially simple, however it actually raises several new problems. The main two are,
		\begin{itemize}
			\item Consistency of Builder's inputs.
			\item Consistency of Executor's inputs.
			\item Output determination.
		\end{itemize}
	\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Lindell-Pinkas 2010}
	\begin{itemize}[<+->]
		\item Based around a new primitive, a Cut and Choose Oblivious Transfer.
		\item Using an elegant approach to consistency using Zero Knowledge proofs.
		\item Half of the circuits are check circuits, the other half are evaluation circuits.
		\item Return majority output of the evaluation circuits.
		\item Statistical security $2^{-0.311 \cdot S}$  where $S$ is the number of circuits.
		\item So we need $130$ circuits to achieve statistical security of $2^{-40}$.
		%\begin{itemize}
		%	\item  
		%\end{itemize}
	\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Lindell 2013}
	\begin{itemize}[<+->]
		\item Very similar to the Lindell-Pinkas 2010, uses the same basic ideas.
		\item Modifies the Cut and Choose Oblivious Transfer.
		\item Runs a small sub-computation (using Lindell-Pinkas) such that only one circuit needs to be correct.
		\item So it's expected to do well for large circuits, badly for small circuits.
		\item Statistical security $2^{-S}$ , so we need $40$ circuits to achieve statistical security of $2^{-40}$.
	\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Huang-Katz-Evans 2013}
	\begin{itemize}[<+->]
		\item Developed concurrently to Lindell 2013.
		\item Uses Symmetric cut and choose. Both parties build circuits, both circuits execute the other's circuits.
		\item Output determination is such that 
		\item Statistical security $2^{-S + log(S)}$ , so we need $46$ circuits to achieve statistical security of $2^{-40}$.
	\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Merging Lindell and HKE}
	\begin{itemize}[<+->]
		\item The obvious question raised by Lindell 2013 is can we improve it by changing 
	\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\begin{block}{32-bit Addition Circuit Results}
		\begin{tabular}{| r | c c c c |}
		\hline
		\textbf{Builder} & \textbf{CPU Time} & \textbf{Wall Time} & \textbf{Bytes Sent} & \textbf{Bytes Recv} \\
		\hline
		\hline
		LP 2010 & $113.96$ & $27.41$ & $7,648,074$ & $737,109$ \\
		\hline
		L 2013 & $171.21$ & $42.03$ & $4,693,761$ & $980,193$ \\
		\hline
		HKE 2013 & $45.59$ & $6.77$ & $3,143,383$ & $3,143,366$ \\
		\hline
		L-HKE & $145.77$ & $25.47$ & $5,995,366$ & $3,299,399$ \\
		\hline
		\end{tabular}

		\vspace{0.2cm}

		\begin{tabular}{| r | c c c c |}
		\hline
		\textbf{Executor} & \textbf{CPU Time} & \textbf{Wall Time} & \textbf{Bytes Sent} & \textbf{Bytes Recv} \\
		\hline
		\hline
		LP 2010 & $55.90$ & $27.45$ & $737,109$ & $7,648,074$ \\
		\hline
		L 2013 & $101.69$ & $42.05$ & $980,193$ & $4,693,761$ \\
		\hline
		HKE 2013 & $45.59$ & $6.77$ & $3,143,366$ & $3,143,383$ \\
		\hline
		L-HKE & $132.51$ & $25.83$ & $3,299,399$ & $5,995,366$ \\
		\hline
		\end{tabular}
	\end{block}
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
	\begin{block}{AES-128 Encryption Circuit Results}
		\begin{tabular}{| r | c c c c |}
		\hline
		\textbf{Builder} & \textbf{CPU Time} & \textbf{Wall Time} & \textbf{Bytes Sent} & \textbf{Bytes Recv} \\
		\hline
		\hline
		LP 2010 & $480.82$ & $114.98$ & $668,935,684$ & $2,798,517$ \\
		\hline
		L 2013 & $399.27$ & $119.25$ & $210,537,538$ & $1,609,692$ \\
		\hline
		HKE 2013 & $185.47$ & $32.95$ & $238,300,835$ & $238,300,840$ \\
		\hline
		L-HKE & $417.84$ & $78.22$ & $214,725,419$ & $7,868,176$ \\
		\hline
		\end{tabular}

		\vspace{0.2cm}

		\begin{tabular}{| r | c c c c |}
		\hline
		\textbf{Executor} & \textbf{CPU Time} & \textbf{Wall Time} & \textbf{Bytes Sent} & \textbf{Bytes Recv} \\
		\hline
		\hline
		LP 2010 & $227.91$ & $116.15$ & $2,798,517$ & $668,935,684$ \\
		\hline
		L 2013 & $270.99$ & $119.27$ & $1,609,692$ & $210,537,538$ \\
		\hline
		HKE 2013 & $185.47$ & $32.95$ & $238,300,840$ & $238,300,835$ \\
		\hline
		L-HKE & $363.46$ & $80.49$ & $7,868,176$ & $214,725,419$ \\
		\hline
		\end{tabular}
	\end{block}


\end{frame}



\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
















